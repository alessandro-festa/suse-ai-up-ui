import { ref, onMounted, onUnmounted } from 'vue';
import { logger } from '../utils/logger';

export interface HealthStatus {
  status: 'healthy' | 'unhealthy';
  timestamp: string;
  version?: string;
  service: string;
}

export interface ServiceHealth {
  status: HealthStatus | null;
  loading: boolean;
  error: string | null;
}

export function useHealthMonitoring() {
  // Reactive state for each service
  const proxyHealth = ref<ServiceHealth>({
    status: null,
    loading: false,
    error: null
  });

  const registryHealth = ref<ServiceHealth>({
    status: null,
    loading: false,
    error: null
  });

  const discoveryHealth = ref<ServiceHealth>({
    status: null,
    loading: false,
    error: null
  });

  // Polling interval
  let pollInterval: ReturnType<typeof setInterval> | null = null;

  // Health check functions
  const checkProxyHealth = async (): Promise<void> => {
    proxyHealth.value.loading = true;
    proxyHealth.value.error = null;

    try {
      const proxyHost = window.location.hostname;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);

      try {
        const response = await fetch(`http://${proxyHost}:8911/health`, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        const data = await response.json();

        proxyHealth.value.status = {
          status: response.ok ? 'healthy' : 'unhealthy',
          timestamp: new Date().toISOString(),
          version: data.version,
          service: 'proxy'
        };

        logger.info('Proxy health check successful', { status: proxyHealth.value.status.status });

      } catch (error) {
        clearTimeout(timeoutId);
        proxyHealth.value.status = {
          status: 'unhealthy',
          timestamp: new Date().toISOString(),
          service: 'proxy'
        };
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        proxyHealth.value.error = errorMessage;
        logger.warn('Proxy health check failed', { error: errorMessage });
      } finally {
        proxyHealth.value.loading = false;
      }
  };

  const checkRegistryHealth = async (): Promise<void> => {
    registryHealth.value.loading = true;
    registryHealth.value.error = null;

    try {
      const proxyHost = window.location.hostname;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);

      const response = await fetch(`http://${proxyHost}:8913/health`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      const data = await response.json();

      registryHealth.value.status = {
        status: response.ok ? 'healthy' : 'unhealthy',
        timestamp: new Date().toISOString(),
        version: data.version,
        service: 'registry'
      };

      logger.info('Registry health check successful', { status: registryHealth.value.status.status });

    } catch (error) {
        clearTimeout(timeoutId);
        registryHealth.value.status = {
          status: 'unhealthy',
          timestamp: new Date().toISOString(),
          service: 'registry'
        };
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        registryHealth.value.error = errorMessage;
        logger.warn('Registry health check failed', { error: errorMessage });
      } finally {
        registryHealth.value.loading = false;
      }
  };

  const checkDiscoveryHealth = async (): Promise<void> => {
    discoveryHealth.value.loading = true;
    discoveryHealth.value.error = null;

    try {
      const proxyHost = window.location.hostname;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);

      const response = await fetch(`http://${proxyHost}:8911/health`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      const data = await response.json();

      discoveryHealth.value.status = {
        status: response.ok ? 'healthy' : 'unhealthy',
        timestamp: new Date().toISOString(),
        version: data.version,
        service: 'discovery'
      };

      logger.info('Discovery health check successful', { status: discoveryHealth.value.status.status });

    } catch (error) {
        clearTimeout(timeoutId);
        discoveryHealth.value.status = {
          status: 'unhealthy',
          timestamp: new Date().toISOString(),
          service: 'discovery'
        };
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        discoveryHealth.value.error = errorMessage;
        logger.warn('Discovery health check failed', { error: errorMessage });
      } finally {
        discoveryHealth.value.loading = false;
      }
  };

  // Check all services
  const checkAllHealth = async (): Promise<void> => {
    await Promise.allSettled([
      checkProxyHealth(),
      checkRegistryHealth(),
      checkDiscoveryHealth()
    ]);
  };

  // Manual refresh functions
  const refreshProxyHealth = () => checkProxyHealth();
  const refreshRegistryHealth = () => checkRegistryHealth();
  const refreshDiscoveryHealth = () => checkDiscoveryHealth();
  const refreshAllHealth = () => checkAllHealth();

  // Start polling
  const startPolling = () => {
    if (pollInterval) {
      clearInterval(pollInterval);
    }
    pollInterval = setInterval(() => {
      checkAllHealth();
    }, 120000); // 2 minutes
  };

  // Stop polling
  const stopPolling = () => {
    if (pollInterval) {
      clearInterval(pollInterval);
      pollInterval = null;
    }
  };

  // Initialize on mount
  onMounted(async () => {
    await checkAllHealth();
    startPolling();
  });

  // Cleanup on unmount
  onUnmounted(() => {
    stopPolling();
  });

  return {
    // Health states
    proxyHealth,
    registryHealth,
    discoveryHealth,

    // Check functions
    checkProxyHealth,
    checkRegistryHealth,
    checkDiscoveryHealth,
    checkAllHealth,

    // Refresh functions
    refreshProxyHealth,
    refreshRegistryHealth,
    refreshDiscoveryHealth,
    refreshAllHealth,

    // Polling controls
    startPolling,
    stopPolling
  };
}