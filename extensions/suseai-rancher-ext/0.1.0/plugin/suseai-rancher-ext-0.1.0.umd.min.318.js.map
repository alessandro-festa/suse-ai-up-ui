{"version":3,"file":"suseai-rancher-ext-0.1.0.umd.min.318.js","mappings":"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","sources":["webpack://suseai-rancher-ext-0.1.0/./services/adapter-api.ts","webpack://suseai-rancher-ext-0.1.0/./config/api-config.ts","webpack://suseai-rancher-ext-0.1.0/./composables/useAdapters.ts","webpack://suseai-rancher-ext-0.1.0/./utils/logger.ts","webpack://suseai-rancher-ext-0.1.0/./services/base-api.ts","webpack://suseai-rancher-ext-0.1.0/./services/registry-api.ts"],"sourcesContent":["// Adapter API Service\n// Handles MCP adapter management (CRUD operations, sync, capabilities)\n\nimport { BaseAPI, APIConfig, AuthHeaders } from './base-api'\nimport { logger } from '../utils/logger'\nimport { API_BASE_URLS } from '../config/api-config'\nimport type { MCPClientConfig } from '../types/mcp-types'\n\nexport interface Adapter {\n  id: string\n  mcpServerId?: string\n  name: string\n  description?: string\n  environmentVariables?: Record<string, string>\n  authentication?: AdapterAuthConfig\n  mcpClientConfig?: MCPClientConfig\n  capabilities?: AdapterCapabilities\n  status?: string\n  createdAt?: string\n  [key: string]: any\n}\n\nexport interface AdapterAuthConfig {\n  type: 'bearer' | 'oauth' | 'basic' | 'apikey' | 'none'\n  required: boolean\n  bearerToken?: {\n    dynamic: boolean\n    token?: string\n    expiresAt?: string\n  }\n  oauth?: {\n    clientId: string\n    clientSecret: string\n    authUrl: string\n    tokenUrl: string\n    redirectUri: string\n    scopes: string[]\n  }\n  basic?: {\n    username: string\n    password: string\n  }\n  apiKey?: {\n    key: string\n    location: 'header' | 'query' | 'cookie'\n    name: string\n  }\n}\n\n\n\nexport interface MCPServerConfig {\n  url: string\n  auth: {\n    type: string\n    token: string\n  }\n}\n\nexport interface AdapterCapabilities {\n  tools: MCPTool[]\n  resources: MCPResource[]\n  prompts: MCPPrompt[]\n  lastRefreshed: string\n}\n\nexport interface MCPTool {\n  name: string\n  description: string\n  inputSchema: Record<string, any>\n}\n\nexport interface MCPResource {\n  uri: string\n  name: string\n  description: string\n  mimeType: string\n}\n\nexport interface MCPPrompt {\n  name: string\n  description: string\n  arguments: Array<{\n    name: string\n    description?: string\n    required?: boolean\n  }>\n}\n\nexport interface CreateAdapterRequest {\n  mcpServerId: string\n  name: string\n  description?: string\n  environmentVariables?: Record<string, string>\n  authentication: AdapterAuthConfig\n}\n\nexport interface UpdateAdapterRequest {\n  name?: string\n  description?: string\n  environmentVariables?: Record<string, string>\n  authentication?: AdapterAuthConfig\n}\n\nexport class AdapterAPI extends BaseAPI {\n  constructor(config: APIConfig) {\n    super(config)\n  }\n\n  protected getAuthHeaders(): AuthHeaders | null {\n    // Adapter operations don't require authentication headers to avoid CORS issues\n    return null\n  }\n\n  // Update baseURL dynamically\n  updateBaseURL() {\n    this.api.defaults.baseURL = API_BASE_URLS.MCP_GATEWAY\n  }\n\n  // Get current baseURL\n  getBaseURL() {\n    return this.api.defaults.baseURL\n  }\n\n  /**\n    * Create a new adapter\n    */\n  async create(data: CreateAdapterRequest): Promise<Adapter> {\n    try {\n      logger.info('Creating adapter', { name: data.name, serverId: data.mcpServerId })\n\n        const adapter = await this.post<Adapter>('/api/v1/adapters', data)\n      logger.info('Adapter created', { id: adapter.id, name: adapter.name })\n\n      return adapter\n    } catch (error) {\n      logger.error('Failed to create adapter', error)\n      throw error\n    }\n  }\n\n   /**\n    * List all adapters\n    */\n  async list(): Promise<Adapter[]> {\n    try {\n      logger.info('Listing adapters')\n\n        const response = await this.get<any>('/api/v1/adapters')\n\n      // Handle different response formats\n      let adapters: Adapter[]\n      if (Array.isArray(response)) {\n        adapters = response as Adapter[]\n      } else if (response && Array.isArray(response.adapters)) {\n        adapters = response.adapters as Adapter[]\n      } else if (response && typeof response === 'object') {\n        // Try to find array in any property\n        const arrayProp = Object.values(response).find(val => Array.isArray(val))\n        adapters = arrayProp ? (arrayProp as Adapter[]) : []\n      } else {\n        adapters = []\n      }\n\n      logger.info('Adapters listed', { count: adapters.length })\n\n      return adapters\n    } catch (error) {\n      logger.error('Failed to list adapters', error)\n      console.error('Adapter list error:', error)\n      throw error\n    }\n  }\n\n   /**\n    * Get adapter by ID\n    */\n   async getAdapter(id: string): Promise<Adapter> {\n     try {\n       logger.info('Getting adapter', { id })\n\n        const adapter = await this.get<Adapter>(`/api/v1/adapters/${id}`)\n       logger.info('Adapter retrieved', { id, name: adapter.name })\n\n       return adapter\n     } catch (error) {\n       logger.error('Failed to get adapter', { id, error })\n       throw error\n     }\n   }\n\n   /**\n    * Update adapter\n    */\n   async update(id: string, data: UpdateAdapterRequest): Promise<Adapter> {\n     try {\n       logger.info('Updating adapter', { id })\n\n        const adapter = await this.put<Adapter>(`/api/v1/adapters/${id}`, data)\n       logger.info('Adapter updated', { id, name: adapter.name })\n\n       return adapter\n     } catch (error) {\n       logger.error('Failed to update adapter', { id, error })\n       throw error\n     }\n   }\n\n   /**\n    * Delete adapter\n    */\n   async deleteAdapter(id: string): Promise<void> {\n     try {\n       logger.info('Deleting adapter', { id })\n\n        await this.delete<void>(`/api/v1/adapters/${id}`)\n       logger.info('Adapter deleted', { id })\n\n     } catch (error) {\n       logger.error('Failed to delete adapter', { id, error })\n       throw error\n     }\n   }\n\n   /**\n    * Sync adapter capabilities\n    */\n   async sync(id: string): Promise<AdapterCapabilities> {\n     try {\n       logger.info('Syncing adapter capabilities', { id })\n\n        const capabilities = await this.post<AdapterCapabilities>(`/api/v1/adapters/${id}/sync`)\n       logger.info('Adapter capabilities synced', { id })\n\n       return capabilities\n     } catch (error) {\n       logger.error('Failed to sync adapter capabilities', { id, error })\n       throw error\n     }\n   }\n}\n\n// Singleton instance - will update baseURL dynamically\nexport const adapterAPI = new AdapterAPI({\n  baseURL: API_BASE_URLS.MCP_GATEWAY,\n  timeout: 30000,\n  retries: 3\n})","/**\n * API Configuration for SUSE AI Rancher Extension\n * Centralizes all API endpoints and base URLs\n */\n\nimport { reactive, ref } from 'vue';\n\n// Base URLs for different services\nexport const getApiBaseUrls = (serviceUrl?: string, useHttps: boolean = false) => {\n  const protocol = useHttps ? 'https' : 'http';\n  const mcpPort = useHttps ? 38911 : 8911;\n  const discoveryPort = useHttps ? 38911 : 8911;\n  const proxyPort = useHttps ? 38911 : 8911;\n\n  if (serviceUrl) {\n    // Extract IP from serviceUrl (e.g., http://192.168.1.100:8911 -> 192.168.1.100)\n    const url = new URL(serviceUrl);\n    const ip = url.hostname;\n    return {\n      MCP_GATEWAY: `${protocol}://${ip}:${mcpPort}`,\n      DISCOVERY: `${protocol}://${ip}:${discoveryPort}`,\n      PROXY: `${protocol}://${ip}:${proxyPort}`,\n      REGISTRY: `http://${ip}:8911`,\n      PLUGINS: `http://${ip}:8914`,\n      VIRTUAL_MCP: `http://${ip}:8911/api/v1`,\n      SMART_AGENTS: `http://${ip}:8910`,\n      RANCHER: window.location.origin\n    };\n  }\n\n  // Use current hostname as default instead of hardcoded IP\n  const currentHost = typeof window !== 'undefined' ? window.location.hostname : 'localhost';\n  return {\n    MCP_GATEWAY: `${protocol}://${currentHost}:${mcpPort}`,\n    DISCOVERY: `${protocol}://${currentHost}:${discoveryPort}`,\n    PROXY: `${protocol}://${currentHost}:${proxyPort}`,\n    REGISTRY: `http://${currentHost}:8911`,\n    PLUGINS: `http://${currentHost}:8914`,\n    VIRTUAL_MCP: `http://${currentHost}:8911/api/v1`,\n    SMART_AGENTS: `http://${currentHost}:8910`,\n    RANCHER: window.location.origin\n  };\n};\n\n// HTTPS configuration\nexport const useHttps = ref(false);\n\n// Initialize with default localhost as reactive object\nexport const API_BASE_URLS = reactive(getApiBaseUrls());\n\n// Function to update API base URLs dynamically\nexport const updateApiBaseUrls = (serviceUrl?: string, httpsOverride?: boolean) => {\n  const useHttpsFlag = httpsOverride !== undefined ? httpsOverride : useHttps.value;\n  const newApiBaseUrls = getApiBaseUrls(serviceUrl, useHttpsFlag);\n  // Update the reactive object properties\n  Object.assign(API_BASE_URLS, newApiBaseUrls);\n  return newApiBaseUrls;\n};\n\n// Function to toggle HTTPS mode\nexport const setHttpsMode = (enabled: boolean) => {\n  useHttps.value = enabled;\n  updateApiBaseUrls();\n};\n\n// API Endpoints for MCP Gateway\nexport const MCP_ENDPOINTS = {\n  // Adapter Management\n  ADAPTERS: '/api/v1/adapters',\n  ADAPTER_DETAILS: (name: string) => `/api/v1/adapters/${name}`,\n  ADAPTER_STATUS: (name: string) => `/api/v1/adapters/${name}/status`,\n  ADAPTER_LOGS: (name: string) => `/api/v1/adapters/${name}/logs`,\n   ADAPTER_UPDATE: (name: string) => `/api/v1/adapters/${name}`,\n   ADAPTER_DELETE: (name: string) => `/api/v1/adapters/${name}`,\n   ADAPTER_HEALTH: (name: string) => `/api/v1/adapters/${name}/health`,\n\n  // Session Management\n  SESSIONS: (name: string) => `/api/v1/adapters/${name}/sessions`,\n  SESSIONS_REINITIALIZE: (name: string) => `/api/v1/adapters/${name}/sessions`,\n\n  // Token Management\n  ADAPTER_TOKEN: (name: string) => `/api/v1/adapters/${name}/token`,\n  ADAPTER_TOKEN_REFRESH: (name: string) => `/api/v1/adapters/${name}/token/refresh`,\n  ADAPTER_TOKEN_VALIDATE: (name: string) => `/api/v1/adapters/${name}/token/validate`,\n  ADAPTER_CLIENT_TOKEN: (name: string) => `/api/v1/adapters/${name}/client-token`,\n  ADAPTER_TEST_AUTH: (name: string) => `/api/v1/adapters/${name}/test-auth`,\n  ADAPTER_VALIDATE_AUTH: (name: string) => `/api/v1/adapters/${name}/validate-auth`,\n\n  // MCP Communication\n  ADAPTER_SSE: (name: string) => `/api/v1/adapters/${name}/sse`,\n  ADAPTER_MESSAGES: (name: string) => `/api/v1/adapters/${name}/messages`,\n  ADAPTER_MCP: (name: string) => `/api/v1/adapters/${name}/mcp`,\n  ADAPTER_WEBSOCKET: (name: string) => `/api/v1/adapters/${name}/ws`,\n\n  // Network Discovery\n  DISCOVERY_SCAN: '/api/v1/discovery/scan',\n  DISCOVERY_SERVERS: '/api/v1/discovery/servers',\n  DISCOVERY_RESULTS: '/api/v1/discovery/results',\n  DISCOVERY_SERVER_DETAILS: (id: string) => `/api/v1/discovery/results/${id}`,\n  DISCOVERY_REGISTER: '/api/v1/discovery/register',\n\n  // Legacy endpoints (for backward compatibility)\n   SCAN_START: '/api/v1/discovery/scan',\n   SCAN_STATUS: (scanId: string) => `/api/v1/discovery/scan/${scanId}`,\n  SERVERS: '/api/v1/servers',\n  REGISTER_SERVER: '/api/v1/registry/upload',\n\n  // Registry Management\n  REGISTRY_BROWSE: '/api/v1/registry/browse',\n  REGISTRY_PUBLIC: '/api/v1/registry/browse',\n  REGISTRY_SYNC_OFFICIAL: '/api/v1/registry/reload',\n  REGISTRY_UPLOAD: '/api/v1/registry/upload',\n  REGISTRY_UPLOAD_BULK: '/api/v1/registry/upload',\n  REGISTRY_UPLOAD_LOCAL_MCP: '/api/v1/registry/upload',\n  REGISTRY_DETAILS: (id: string) => `/api/v1/registry/${id}`,\n  REGISTRY_CREATE_ADAPTER: (id: string) => `/api/v1/registry/${id}/create-adapter`,\n\n  // Deployment Management\n  DEPLOYMENT_CONFIG: (serverId: string) => `/api/v1/deployment/config/${serverId}`,\n  DEPLOYMENT_DEPLOY: '/api/v1/deployment/deploy',\n\n  // Plugin Services\n  PLUGIN_SERVICES: '/api/v1/plugins',\n  PLUGIN_REGISTER: '/api/v1/plugins',\n  PLUGIN_HEALTH: (serviceId: string) => `/api/v1/plugins/${serviceId}/health`,\n  PLUGIN_UNREGISTER: (serviceId: string) => `/api/v1/plugins/${serviceId}`,\n  PLUGIN_SERVICES_BY_TYPE: (serviceType: string) => `/api/v1/plugins/type/${serviceType}`,\n\n  // System\n  HEALTH: '/health',\n  METRICS: '/metrics',\n  DOCS: '/docs',\n  SWAGGER_JSON: '/swagger.json'\n} as const;\n\n// API Endpoints for Smart Agents\nexport const SMART_AGENTS_ENDPOINTS = {\n  AGENTS: '/agents',\n  AGENT_DETAILS: (id: string) => `/agents/${id}`,\n  AGENT_CREATE: '/agents',\n  AGENT_UPDATE: (id: string) => `/agents/${id}`,\n  AGENT_DELETE: (id: string) => `/agents/${id}`\n} as const;\n\n// API Configuration\nexport const API_CONFIG = {\n  // Default timeout for requests (in milliseconds)\n  DEFAULT_TIMEOUT: 10000,\n  \n  // Retry configuration\n  RETRY_ATTEMPTS: 3,\n  RETRY_DELAY: 1000,\n  \n  // Rate limiting\n  RATE_LIMITS: {\n    MANAGEMENT: 100, // requests per minute\n    COMMUNICATION: 1000, // requests per minute\n    HEALTH_CHECK: Infinity // unlimited\n  },\n  \n  // Headers\n  DEFAULT_HEADERS: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  },\n  \n  // SSE Headers\n  SSE_HEADERS: {\n    'Accept': 'text/event-stream',\n    'Cache-Control': 'no-cache'\n  },\n  \n  // WebSocket configuration\n  WS_CONFIG: {\n    protocols: ['mcp-v1'],\n    reconnectAttempts: 5,\n    reconnectDelay: 2000\n  }\n} as const;\n\n// Environment-specific configuration\nexport const getApiConfig = () => {\n  const isDevelopment = process.env.NODE_ENV === 'development';\n  \n  return {\n    baseURL: API_BASE_URLS.MCP_GATEWAY,\n    timeout: API_CONFIG.DEFAULT_TIMEOUT,\n    headers: API_CONFIG.DEFAULT_HEADERS,\n    retryAttempts: isDevelopment ? 1 : API_CONFIG.RETRY_ATTEMPTS,\n    enableLogging: isDevelopment,\n    validateStatus: (status: number) => status >= 200 && status < 300\n  };\n};\n\n// Helper function to build full URLs\nexport const buildUrl = (base: string, endpoint: string): string => {\n  return `${base.replace(/\\/$/, '')}${endpoint}`;\n};\n\n// Helper function to get MCP Gateway URLs\nexport const getMcpUrl = (endpoint: string): string => {\n  return buildUrl(API_BASE_URLS.MCP_GATEWAY, endpoint);\n};\n\n// Helper function to get Smart Agents URLs\nexport const getSmartAgentsUrl = (endpoint: string): string => {\n  return buildUrl(API_BASE_URLS.SMART_AGENTS, endpoint);\n};\n\nexport default {\n  API_BASE_URLS,\n  MCP_ENDPOINTS,\n  SMART_AGENTS_ENDPOINTS,\n  API_CONFIG,\n  getApiConfig,\n  buildUrl,\n  getMcpUrl,\n  getSmartAgentsUrl,\n  useHttps,\n  setHttpsMode\n};","// Adapters Composable\n// Provides state management and API integration for MCP adapters\n\nimport { ref, readonly } from 'vue'\nimport { adapterAPI, type Adapter, type CreateAdapterRequest, type UpdateAdapterRequest, type AdapterCapabilities } from '../services/adapter-api'\nimport { logger } from '../utils/logger'\n\nexport function useAdapters() {\n  const adapters = ref<Adapter[]>([])\n  const loading = ref(false)\n  const error = ref<string | null>(null)\n  let pollInterval: NodeJS.Timeout | null = null\n\n  // Load all adapters\n  const loadAdapters = async (): Promise<void> => {\n    loading.value = true\n    error.value = null\n\n      try {\n        logger.info('Loading adapters')\n        const adapterList = await adapterAPI.list()\n        adapters.value = adapterList\n        logger.info('Adapters loaded', { count: adapterList.length })\n      } catch (err: any) {\n        error.value = err.message || 'Failed to load adapters'\n        logger.error('Failed to load adapters', err)\n      } finally {\n        loading.value = false\n      }\n  }\n\n  // Create new adapter\n  const createAdapter = async (data: CreateAdapterRequest): Promise<Adapter | null> => {\n    loading.value = true\n    error.value = null\n\n    try {\n      logger.info('Creating adapter', { name: data.name, serverId: data.mcpServerId })\n      const adapter = await adapterAPI.create(data)\n      adapters.value.push(adapter)\n      logger.info('Adapter created', { id: adapter.id, name: adapter.name })\n      return adapter\n    } catch (err: any) {\n      error.value = err.message || 'Failed to create adapter'\n      logger.error('Failed to create adapter', err)\n      return null\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // Start polling for adapter updates\n  const startPolling = () => {\n    if (pollInterval) {\n      clearInterval(pollInterval)\n    }\n    pollInterval = setInterval(() => {\n      loadAdapters()\n    }, 30000) // Poll every 30 seconds\n    logger.info('Started polling adapters')\n  }\n\n  // Stop polling\n  const stopPolling = () => {\n    if (pollInterval) {\n      clearInterval(pollInterval)\n      pollInterval = null\n      logger.info('Stopped polling adapters')\n    }\n  }\n\n  // Get adapter by ID\n  const getAdapter = async (id: string): Promise<Adapter | null> => {\n    try {\n      logger.info('Getting adapter', { id })\n      return await adapterAPI.getAdapter(id)\n    } catch (err: any) {\n      logger.error('Failed to get adapter', { id, error: err })\n      return null\n    }\n  }\n\n  // Update adapter\n  const updateAdapter = async (id: string, data: UpdateAdapterRequest): Promise<Adapter | null> => {\n    loading.value = true\n    error.value = null\n\n    try {\n      logger.info('Updating adapter', { id })\n      const adapter = await adapterAPI.update(id, data)\n\n      // Update local state\n      const index = adapters.value.findIndex(a => a.id === id)\n      if (index >= 0) {\n        adapters.value[index] = adapter\n      }\n\n      logger.info('Adapter updated', { id, name: adapter.name })\n      return adapter\n    } catch (err: any) {\n      error.value = err.message || 'Failed to update adapter'\n      logger.error('Failed to update adapter', { id, error: err })\n      return null\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // Delete adapter\n  const deleteAdapter = async (id: string): Promise<boolean> => {\n    loading.value = true\n    error.value = null\n\n    try {\n      logger.info('Deleting adapter', { id })\n      await adapterAPI.deleteAdapter(id)\n\n      // Remove from local state\n      adapters.value = adapters.value.filter(a => a.id !== id)\n\n      logger.info('Adapter deleted', { id })\n      return true\n    } catch (err: any) {\n      error.value = err.message || 'Failed to delete adapter'\n      logger.error('Failed to delete adapter', { id, error: err })\n      return false\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // Sync adapter capabilities\n  const syncAdapter = async (id: string): Promise<AdapterCapabilities | null> => {\n    loading.value = true\n    error.value = null\n\n    try {\n      logger.info('Syncing adapter capabilities', { id })\n      const capabilities = await adapterAPI.sync(id)\n\n      // Update local adapter with new capabilities\n      const index = adapters.value.findIndex(a => a.id === id)\n      if (index >= 0) {\n        adapters.value[index].capabilities = capabilities\n        adapters.value[index].capabilities.lastRefreshed = new Date().toISOString()\n      }\n\n      logger.info('Adapter capabilities synced', { id })\n      return capabilities\n    } catch (err: any) {\n      error.value = err.message || 'Failed to sync adapter capabilities'\n      logger.error('Failed to sync adapter capabilities', { id, error: err })\n      return null\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // Get adapter by ID from local state\n  const getAdapterById = (id: string): Adapter | undefined => {\n    return adapters.value.find(adapter => adapter.id === id)\n  }\n\n  // Get adapters by server ID\n  const getAdaptersByServerId = (serverId: string): Adapter[] => {\n    return adapters.value.filter(adapter => adapter.mcpServerId === serverId)\n  }\n\n  // Check if adapter is healthy\n  const isAdapterHealthy = (adapter: Adapter): boolean => {\n    return adapter.status === 'ready' || adapter.status === 'active'\n  }\n\n  // Get adapter status color class\n  const getStatusClass = (status: string): string => {\n    switch (status) {\n      case 'ready':\n      case 'active':\n        return 'text-success'\n      case 'error':\n      case 'failed':\n        return 'text-danger'\n      case 'pending':\n      case 'starting':\n        return 'text-warning'\n      default:\n        return 'text-muted'\n    }\n  }\n\n  // Get adapter status label\n  const getStatusLabel = (status: string): string => {\n    switch (status) {\n      case 'ready':\n        return 'Ready'\n      case 'active':\n        return 'Active'\n      case 'error':\n        return 'Error'\n      case 'failed':\n        return 'Failed'\n      case 'pending':\n        return 'Pending'\n      case 'starting':\n        return 'Starting'\n      default:\n        return 'Unknown'\n    }\n  }\n\n  // Get authentication type label\n  const getAuthTypeLabel = (adapter: Adapter): string => {\n    if (!adapter.authentication?.required) {\n      return 'None'\n    }\n\n    return (adapter.authentication?.type || 'none').charAt(0).toUpperCase() + (adapter.authentication?.type || 'none').slice(1)\n  }\n\n  // Get capabilities summary\n  const getCapabilitiesSummary = (adapter: Adapter) => {\n    const caps = adapter.capabilities || { tools: [], resources: [], prompts: [], lastRefreshed: '' }\n    return {\n      tools: caps.tools?.length || 0,\n      resources: caps.resources?.length || 0,\n      prompts: caps.prompts?.length || 0,\n      lastRefreshed: caps.lastRefreshed\n    }\n  }\n\n  return {\n    // State\n    adapters,\n    loading,\n    error,\n\n    // Methods\n    loadAdapters,\n    createAdapter,\n    getAdapter,\n    updateAdapter,\n    deleteAdapter,\n    syncAdapter,\n    startPolling,\n    stopPolling,\n    getAdapterById,\n    getAdaptersByServerId,\n    isAdapterHealthy,\n    getStatusClass,\n    getStatusLabel,\n    getAuthTypeLabel,\n    getCapabilitiesSummary\n  }\n}","// Logger utility\n\nexport const logger = {\n  info: (message: string, ...args: any[]) => console.info(`[SUSE AI] ${message}`, ...args),\n  warn: (message: string, ...args: any[]) => console.warn(`[SUSE AI] ${message}`, ...args),\n  error: (message: string, ...args: any[]) => console.error(`[SUSE AI] ${message}`, ...args)\n};","// Base API class for SUSE AI Universal Proxy\n// Provides consistent error handling, authentication, and request patterns\n\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'\nimport { logger } from '../utils/logger'\n\nexport interface APIConfig {\n  baseURL: string\n  timeout: number\n  retries: number\n  dynamicBaseURL?: () => string\n}\n\nexport interface AuthHeaders {\n  'X-API-Key'?: string\n  'X-User-ID'?: string\n  'Authorization'?: string\n}\n\nexport interface AuthMode {\n  mode: 'local' | 'github' | 'rancher' | 'dev'\n  github?: {\n    clientId: string\n    redirectUri: string\n  }\n  rancher?: {\n    issuerUrl: string\n    clientId: string\n    redirectUri: string\n  }\n}\n\nexport interface AuthToken {\n  token: string\n  tokenType: string\n  expiresAt: string\n  userId: string\n}\n\nexport interface APIError {\n  code: string\n  message: string\n  details?: Record<string, any>\n  status?: number\n}\n\nexport class BaseAPI {\n  protected api: AxiosInstance\n  protected config: APIConfig\n\n  constructor(config: APIConfig) {\n    this.config = config\n    this.api = axios.create({\n      baseURL: config.baseURL || undefined, // Allow empty baseURL to be set dynamically\n      timeout: config.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n    this.setupInterceptors()\n  }\n\n  // Get current baseURL\n  getBaseURL(): string | undefined {\n    return this.api.defaults.baseURL\n  }\n\n  private setupInterceptors() {\n    // Request interceptor for authentication\n    this.api.interceptors.request.use(\n      (config) => {\n        const authHeaders = this.getAuthHeaders()\n        if (authHeaders) {\n          Object.assign(config.headers, authHeaders)\n        }\n        return config\n      },\n      (error) => {\n        logger.error('Request interceptor error:', error)\n        return Promise.reject(error)\n      }\n    )\n\n    // Response interceptor for error handling\n    this.api.interceptors.response.use(\n      (response) => response,\n      (error) => {\n        const apiError = this.handleError(error)\n        return Promise.reject(apiError)\n      }\n    )\n  }\n\n  protected getAuthHeaders(): AuthHeaders | null {\n    // Always check for stored token\n    const stored = localStorage.getItem('suseai-auth-token')\n    if (stored) {\n      try {\n        const token: AuthToken = JSON.parse(stored)\n        // Check if token is expired\n        if (new Date(token.expiresAt) > new Date()) {\n          return {\n            'Authorization': `Bearer ${token.token}`\n          }\n        } else {\n          localStorage.removeItem('suseai-auth-token')\n        }\n      } catch (error) {\n        localStorage.removeItem('suseai-auth-token')\n      }\n    }\n    // No fallback headers when authentication is disabled\n    return null\n  }\n\n  // Token management\n  protected setAuthToken(token: AuthToken): void {\n    try {\n      localStorage.setItem('suseai-auth-token', JSON.stringify(token))\n    } catch (error) {\n      logger.warn('Failed to store auth token:', error)\n    }\n  }\n\n  protected clearAuthToken(): void {\n    try {\n      localStorage.removeItem('suseai-auth-token')\n    } catch (error) {\n      logger.warn('Failed to clear auth token:', error)\n    }\n  }\n\n  // Get authentication mode (unauthenticated)\n  public async getAuthMode(): Promise<AuthMode> {\n    // Use a direct axios call without auth headers\n    const response = await axios.get(`${this.getBaseURL()}/auth/mode`, {\n      timeout: this.config.timeout\n    })\n    return response.data\n  }\n\n  protected handleError(error: any): APIError {\n    if (error.response) {\n      // Server responded with error status\n      const { status, data } = error.response\n      return {\n        code: data?.code || `HTTP_${status}`,\n        message: data?.error || data?.message || `HTTP ${status} error`,\n        details: data?.details,\n        status\n      }\n    } else if (error.request) {\n      // Request was made but no response received\n      return {\n        code: 'NETWORK_ERROR',\n        message: 'Network error - please check your connection',\n        details: { originalError: error.message }\n      }\n    } else {\n      // Something else happened\n      return {\n        code: 'UNKNOWN_ERROR',\n        message: error.message || 'An unexpected error occurred',\n        details: { originalError: error }\n      }\n    }\n  }\n\n  protected async request<T>(\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    url: string,\n    data?: any,\n    config?: AxiosRequestConfig\n  ): Promise<T> {\n    try {\n      // Merge config with dynamic baseURL if needed\n      const requestConfig = {\n        method,\n        url,\n        data,\n        ...config\n      }\n\n      // Use dynamic baseURL if available and no baseURL set\n      if (!requestConfig.baseURL && this.config.dynamicBaseURL) {\n        requestConfig.baseURL = this.config.dynamicBaseURL()\n      }\n\n      const response: AxiosResponse<T> = await this.api.request(requestConfig)\n      return response.data\n    } catch (error) {\n      // Error already handled by interceptor\n      throw error\n    }\n  }\n\n  // Convenience methods\n  protected async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>('GET', url, undefined, config)\n  }\n\n  protected async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>('POST', url, data, config)\n  }\n\n  protected async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>('PUT', url, data, config)\n  }\n\n  protected async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>('DELETE', url, undefined, config)\n  }\n}","// Registry API Service\n// Handles MCP server registry operations (browsing, details, reload)\n\nimport { BaseAPI, APIConfig, AuthHeaders } from './base-api'\nimport { logger } from '../utils/logger'\nimport { API_BASE_URLS, MCP_ENDPOINTS } from '../config/api-config'\n\nexport interface MCPServer {\n  readonly id: string\n  readonly name: string\n  readonly description: string\n  readonly icon?: string\n  readonly about?: {\n    readonly icon_url: string\n    readonly title: string\n  }\n  readonly type?: string\n  readonly secrets?: readonly {\n    readonly name: string\n    readonly description?: string\n    readonly value?: string\n  }[]\n  readonly tags?: readonly string[]\n  readonly source_url?: string\n  readonly project_url?: string\n  readonly packages: readonly Package[]\n  readonly tools?: readonly any[]\n  readonly config_template?: any\n  readonly address?: string\n  readonly port?: number\n  readonly protocol?: string\n  readonly connection?: string\n  readonly discoveredAt?: string\n  readonly lastSeen?: string\n  readonly metadata?: any\n  readonly validation_status?: string\n   readonly _meta: {\n      readonly source: string\n      readonly userAuthRequired: boolean\n      readonly authType: string\n      readonly category: string\n      readonly tags: readonly string[]\n      readonly documentation?: string\n      readonly hosted?: boolean\n      readonly requiresInstallation?: boolean\n      readonly transportType?: string\n      readonly validation_status?: string\n      readonly badges?: readonly string[]\n      readonly config?: {\n        readonly secrets?: readonly {\n          readonly name: string\n          readonly env: string\n          readonly description?: string\n          readonly example?: string\n          readonly required?: boolean\n        }[]\n      }\n    }\n}\n\nexport interface Package {\n  readonly registryType: string\n  readonly identifier: string\n  readonly transport: {\n    readonly type: string\n  }\n  readonly environmentVariables?: ReadonlyArray<{\n    readonly name: string\n    readonly description?: string\n    readonly default?: string\n    readonly required?: boolean\n    readonly isSecret?: boolean\n  }>\n}\n\nexport interface RegistryBrowseParams {\n  q?: string\n  category?: string\n  limit?: number\n  offset?: number\n}\n\nexport interface RegistryBrowseResult {\n  servers: MCPServer[]\n  total: number\n  hasMore: boolean\n}\n\nexport class RegistryAPI extends BaseAPI {\n  constructor(config: APIConfig) {\n    super(config)\n  }\n\n  protected getAuthHeaders(): AuthHeaders | null {\n    // Registry browsing is public, no auth required\n    return null\n  }\n\n  // Update baseURL dynamically\n  updateBaseURL() {\n    this.api.defaults.baseURL = API_BASE_URLS.REGISTRY\n  }\n\n  /**\n   * Browse MCP servers from registry\n   */\n  async browse(params: RegistryBrowseParams = {}): Promise<RegistryBrowseResult> {\n    try {\n      logger.info('Browsing MCP registry', { params })\n\n        const queryParams = new URLSearchParams()\n       if (params.q) queryParams.append('q', params.q)\n       if (params.category) queryParams.append('category', params.category)\n       if (params.limit) queryParams.append('limit', params.limit.toString())\n       if (params.offset) queryParams.append('offset', params.offset.toString())\n\n         const url = `${MCP_ENDPOINTS.REGISTRY_BROWSE}${queryParams.toString() ? `?${queryParams.toString()}` : ''}`\n\n        const result = await this.get<RegistryBrowseResult>(url)\n\n        // Debug: log the raw result\n        logger.info('Raw registry browse result type:', typeof result)\n        logger.info('Is array result?', Array.isArray(result))\n        logger.info('Result length if array:', Array.isArray(result) ? result.length : 'N/A')\n        logger.info('First server id if array:', Array.isArray(result) && result.length > 0 ? result[0].id : 'N/A')\n\n        // Ensure result has expected structure\n        let servers: MCPServer[] = []\n        let total = 0\n        let hasMore = false\n\n        if (!result) {\n          logger.warn('Invalid registry browse result: null or undefined', result)\n          return { servers: [], total: 0, hasMore: false }\n        }\n\n        // Handle different response formats\n        if (Array.isArray(result)) {\n            // Raw array format (fallback for server.json) - transform to expected structure\n            servers = result.map((server: any) => ({\n              id: server.id || server.name, // Use name as id if id is not provided\n              name: server._meta?.about?.title || server._meta?.title || server.title || server.name,\n              description: server._meta?.about?.description || server._meta?.description || server.description || server.about?.description,\n              icon: server._meta?.about?.icon || server._meta?.icon || server.icon || server.about?.icon,\n              about: {\n                icon_url: server._meta?.about?.icon || server.about?.icon_url,\n                title: server._meta?.about?.title || server.about?.title\n              },\n              type: server.type,\n              tags: server.tags || server._meta?.tags || [],\n              packages: server.packages || [],\n               _meta: {\n                 source: server.source || 'registry',\n                 userAuthRequired: false,\n                 authType: 'none',\n                 category: server._meta?.category || 'general',\n                 tags: server._meta?.tags || [],\n                 hosted: server._meta?.hosted,\n                 requiresInstallation: server._meta?.requiresInstallation,\n                 transportType: server._meta?.transportType,\n                 validation_status: server._meta?.validation_status,\n                 badges: server._meta?.badges,\n                 config: server._meta?.config\n               }\n            }))\n          total = servers.length\n          hasMore = false\n          logger.info('Registry returned raw array format, transformed to expected structure')\n        } else if (Array.isArray(result.servers)) {\n          // Expected structured format\n          servers = result.servers\n          total = result.total || servers.length\n          hasMore = result.hasMore || false\n        } else {\n          logger.warn('Invalid registry browse result structure', result)\n          return { servers: [], total: 0, hasMore: false }\n        }\n\n        logger.info('Registry browse completed', { count: servers.length, total })\n\n        return { servers, total, hasMore }\n    } catch (error) {\n      logger.error('Failed to browse registry', error)\n      throw error\n    }\n  }\n\n  /**\n      * Get server details by ID\n      */\n     async getServer(id: string): Promise<MCPServer> {\n       try {\n         logger.info('Getting server details', { id })\n\n         const server = await this.get<MCPServer>(MCP_ENDPOINTS.REGISTRY_DETAILS(id))\n         logger.info('Server details retrieved from API', { id, name: server.name })\n         return server\n       } catch (error) {\n         logger.error('Failed to get server details', { id, error })\n         throw error\n       }\n     }\n\n  /**\n   * Reload the MCP server registry\n   */\n  async reload(): Promise<{ status: string; message: string }> {\n    try {\n      logger.info('Reloading MCP registry')\n\n        const result = await this.post<{ status: string; message: string }>(MCP_ENDPOINTS.REGISTRY_SYNC_OFFICIAL)\n      logger.info('Registry reload completed', result)\n\n      return result\n    } catch (error) {\n      logger.error('Failed to reload registry', error)\n      throw error\n    }\n  }\n}\n\n// Singleton instance\nexport const registryAPI = new RegistryAPI({\n  baseURL: API_BASE_URLS.REGISTRY,\n  timeout: 30000,\n  retries: 3\n})"],"names":["AdapterAPI","BaseAPI","constructor","config","super","getAuthHeaders","updateBaseURL","this","api","defaults","baseURL","API_BASE_URLS","MCP_GATEWAY","getBaseURL","create","data","logger","info","name","serverId","mcpServerId","adapter","post","id","error","list","response","get","adapters","Array","isArray","arrayProp","Object","values","find","val","count","length","console","getAdapter","update","put","deleteAdapter","delete","sync","capabilities","adapterAPI","timeout","retries","getApiBaseUrls","serviceUrl","useHttps","protocol","mcpPort","discoveryPort","proxyPort","url","URL","ip","hostname","DISCOVERY","PROXY","REGISTRY","PLUGINS","VIRTUAL_MCP","SMART_AGENTS","RANCHER","window","location","origin","currentHost","ref","reactive","updateApiBaseUrls","httpsOverride","useHttpsFlag","undefined","value","newApiBaseUrls","assign","MCP_ENDPOINTS","ADAPTERS","ADAPTER_DETAILS","ADAPTER_STATUS","ADAPTER_LOGS","ADAPTER_UPDATE","ADAPTER_DELETE","ADAPTER_HEALTH","SESSIONS","SESSIONS_REINITIALIZE","ADAPTER_TOKEN","ADAPTER_TOKEN_REFRESH","ADAPTER_TOKEN_VALIDATE","ADAPTER_CLIENT_TOKEN","ADAPTER_TEST_AUTH","ADAPTER_VALIDATE_AUTH","ADAPTER_SSE","ADAPTER_MESSAGES","ADAPTER_MCP","ADAPTER_WEBSOCKET","DISCOVERY_SCAN","DISCOVERY_SERVERS","DISCOVERY_RESULTS","DISCOVERY_SERVER_DETAILS","DISCOVERY_REGISTER","SCAN_START","SCAN_STATUS","scanId","SERVERS","REGISTER_SERVER","REGISTRY_BROWSE","REGISTRY_PUBLIC","REGISTRY_SYNC_OFFICIAL","REGISTRY_UPLOAD","REGISTRY_UPLOAD_BULK","REGISTRY_UPLOAD_LOCAL_MCP","REGISTRY_DETAILS","REGISTRY_CREATE_ADAPTER","DEPLOYMENT_CONFIG","DEPLOYMENT_DEPLOY","PLUGIN_SERVICES","PLUGIN_REGISTER","PLUGIN_HEALTH","serviceId","PLUGIN_UNREGISTER","PLUGIN_SERVICES_BY_TYPE","serviceType","HEALTH","METRICS","DOCS","SWAGGER_JSON","API_CONFIG","DEFAULT_TIMEOUT","RETRY_ATTEMPTS","RETRY_DELAY","RATE_LIMITS","MANAGEMENT","COMMUNICATION","HEALTH_CHECK","Infinity","DEFAULT_HEADERS","SSE_HEADERS","WS_CONFIG","protocols","reconnectAttempts","reconnectDelay","getApiConfig","isDevelopment","process","headers","retryAttempts","enableLogging","validateStatus","status","buildUrl","base","endpoint","replace","getMcpUrl","useAdapters","loading","pollInterval","loadAdapters","async","adapterList","err","message","createAdapter","push","startPolling","clearInterval","setInterval","stopPolling","updateAdapter","index","findIndex","a","filter","syncAdapter","lastRefreshed","Date","toISOString","getAdapterById","getAdaptersByServerId","isAdapterHealthy","getStatusClass","getStatusLabel","getAuthTypeLabel","authentication","required","type","charAt","toUpperCase","slice","getCapabilitiesSummary","caps","tools","resources","prompts","args","warn","_defineProperty","axios","setupInterceptors","interceptors","request","use","authHeaders","Promise","reject","apiError","handleError","stored","localStorage","getItem","token","JSON","parse","expiresAt","removeItem","setAuthToken","setItem","stringify","clearAuthToken","getAuthMode","code","details","originalError","method","requestConfig","dynamicBaseURL","RegistryAPI","browse","params","queryParams","URLSearchParams","q","append","category","limit","toString","offset","result","servers","total","hasMore","map","server","_meta","about","title","description","icon","icon_url","tags","packages","source","userAuthRequired","authType","hosted","requiresInstallation","transportType","validation_status","badges","getServer","reload","registryAPI"],"ignoreList":[],"sourceRoot":""}